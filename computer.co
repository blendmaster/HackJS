#attach hack to global object
@hack = 
	# ROM is just an array of functions
	# so there's no point in using a typed array
	# the assembler creates this array when it recieves input
	# ROM: []

	# store reference to the next instruction run
	# so user can stop execution
	timeout: void
	# clock speed (setTimeout delay), defaulting to 0
	# to allow cpu to run as fast as possible
	clock: 100

	# since M is a meta register, recreate its functionality using ES5 getters and setters
	M:~ -> @RAM[ @A ]	
	M:~ (it) -> 
		# write to and refresh screen if necessary
		# lots of dirty work to transform jack memory map into pixels
		if 16384 <= @A <= 24575 
			# each screen word is 16 pixels and each @screen pixel is 4 bytes (RGBA)
			offset = ( @A - 16384 ) * 16 * 4
			p = 0 # pixel offset of memory value
			for i from offset til offset + 64 by 4 # 64 bits -> 4 bytes
				# get bit at position p to get 0->255 (white) or 1->0 (black)
				pixel = if (it >> p++ & 1) then 0 else 255
				@screen.data[ i ] = pixel #R
				@screen.data[ i + 1 ] = pixel #G
				@screen.data[ i + 2 ] = pixel #B

			@refresh!

		# store memory
		@RAM[ @A ] = it

	booted: false

	stop: !-> clearTimeout @timeout

	reset: !->
		@stop!
		@boot!

	# beep boop
	boot: !->
		# two bytes per 16 bit int
		# RAM is cleared on boot
		@RAMBuffer = new ArrayBuffer 24576 * 2
		@RAM = new Int16Array @RAMBuffer

		# init real registers
		@A = 0
		@D = 0

		@PC = 0

		# initialize screen
		@canvas.fillStyle = \white
		@canvas.fillRect 0 0 512 256 # make screen opaque white
		# screen now contains opaque white pixels
		@screen = @canvas.getImageData 0 0 512 256

		@booted = true

	# start setTimeout for next instruction
	start: !-> 
		console.log \starting...
		@timeout = setTimeout @exec, @clock

	# execute current instruction and increment PC
	step: !-> 
		@boot! unless @booted
		console.log "next instruction #{@ROM[@PC].toString!}"
		@ROM[ @PC++ ]! if @PC < @ROM.length
		console.log "after A: #{@A} D: #{@D} M: #{@M} PC: #{@PC}"

	# the reason we must use setTimeout is because
	# the single browser javascript thread will block until finished,
	# preventing any screen redrawing or keyboard interrupts
	# 
	# By using setTimeout, JS will add the next instruction to
	# the execution queue, enabling any queued keyboard/screen redraws
	# to execute before the next instruction
	#
	# not using @this in here because setTimeout calls the raw function without
	# context of the hack object
	exec: !->
		console.log "PC: #{hack.PC}"
		console.log hack.ROM[hack.PC].toString!
		hack.ROM[ hack.PC++ ]! 
		if hack.PC < hack.ROM.length
			hack.timeout = setTimeout hack.exec, hack.clock # queue next instruction

	refresh: !-> @canvas.putImageData @screen, 0 0
